import "oaidl.idl";
import "ocidl.idl";
import "d3d11.idl";

cpp_quote("#ifdef __cplusplus") cpp_quote("}") cpp_quote("#endif")
    cpp_quote("#include \"d2d1_1.h\"") cpp_quote("#ifdef __cplusplus")
        cpp_quote("extern \"C\" {") cpp_quote("#endif") interface ID2D1Device;
interface ID2D1DeviceContext;

/**
Controls the data displayed in the MGDF debug overlay sheet
(press ALT-F12 to see in game)
*/
[
  uuid("D69DC4E5-238B-4427-AF03-628818464E41"), object,
  local
] interface IMGDFDebug : IUnknown {
  /**
   Set some data to display in the overlay
   \param section The section to display the key:value in
   \param key The key to display
   \param value the value to display
   */
  void Set([ in, string ] const small *section, [in] const small *key,
           [ in, string ] const small *value);
  /**
   Clear some data out of the overlay
   \param section to clear the key from
   \param key The key to clear (if null, clears all keys in the section)
   */
  void Clear([in] const small *section, [in] const small *key);

  /**
   Whether the debug overlay is currently visible
   \return whether the debug overlay is currently visible
   */
  BOOL IsShown();

  /**
   Toggle the visibility status of the overlay
   */
  void ToggleShown();
};

/**
Represents a version number
*/
typedef struct MGDFVersion {
  INT32 Major, Minor, Build, Revision;
} MGDFVersion;

/**
A set of preferences that can be persisted
*/
[
  uuid("167C7A2B-AA85-493B-842A-534A14669371"), object,
  local
] interface IMGDFPreferenceSet : IUnknown{};

/**
Provides information regarding the current game being run
and the preferences associated with that game
*/
[
  uuid("8BC6BFEF-09BC-4954-AF2F-5D2619F2CEEE"), object,
  local
] interface IMGDFGame : IUnknown {
  /**
  get the name of the current game running
  \return the name of the current game running
  */
  const small *GetName();

  /**
  get the uid of the current game running
  \return the name of the current game running
  */
  const small *GetUid();

  /**
  get the version of the current game running
  \param version the version of the current game running
  */
  void GetVersion([ in, out ] MGDFVersion * version);

  /**
  determine if the game has a preference for the given key
  \param name the preference name
  \return true if the key has an associated value
  */
  BOOL HasPreference([in] const small *name);

  /**
  determine if the game has a preference for the given key and return its value.
  Preferences can be defined in a games game.json file, or new ones can be
  added/overwritten by calling SetPreference
  \param name the preference name
  \param value buffer to store the value associated with the key or nullptr if there is no such key
  \param length the length of the buffer provided to store the value above. Will be set to the length required
  \return S_OK if the value was found and the buffer was the correct length otherwise E_FAIL
  */
  HRESULT GetPreference([in] const small *name, [ in, out ] small *value,
                        [ in, out ] UINT64 *length);

  /**
  change the value of a preference
  \param name the preference name
  \param value the new preference value
  */
  void SetPreference([in] const small *name, [in] const small *value);

  /**
  Sets a number of preferences in one go. Used for applying system render &
  sound settings
  \param preferences a set of preferences
  */
  void SetPreferences([in] IMGDFPreferenceSet * preferences);

  /**
  save the current preferences list
  */
  void SavePreferences();

  /**
  reload all preferences to their user independent default values
  */
  void ResetPreferences();
};

/**
this is represents all the various mouse buttons that are recognized by the
input manager
*/
typedef enum MGDFMouse {
  MGDF_MOUSE_LEFT,
  MGDF_MOUSE_RIGHT,
  MGDF_MOUSE_MIDDLE
} MGDFMouse;

/**
All the gamepad button types recognized by the input manager
*/
typedef enum MGDFGamepadButton {
  MGDF_GAMEPAD_DPAD_UP = 0x00000001,
  MGDF_GAMEPAD_DPAD_DOWN = 0x00000002,
  MGDF_GAMEPAD_DPAD_LEFT = 0x00000004,
  MGDF_GAMEPAD_DPAD_RIGHT = 0x00000008,
  MGDF_GAMEPAD_START = 0x00000010,
  MGDF_GAMEPAD_BACK = 0x00000020,
  MGDF_GAMEPAD_LEFT_THUMB = 0x00000040,
  MGDF_GAMEPAD_RIGHT_THUMB = 0x00000080,
  MGDF_GAMEPAD_LEFT_SHOULDER = 0x0100,
  MGDF_GAMEPAD_RIGHT_SHOULDER = 0x0200,
  MGDF_GAMEPAD_A = 0x1000,
  MGDF_GAMEPAD_B = 0x2000,
  MGDF_GAMEPAD_X = 0x4000,
  MGDF_GAMEPAD_Y = 0x8000
} MGDFGamepadButton;

/**
Provides the ability to query the state of and control other properties of an
XInput compatible gamepad connected to the PC
*/
[
  uuid("84C7C6BF-827E-4958-8C64-D7FA78D69D0B"), object,
  local
] interface IMGDFGamepad : IUnknown {
  /**
  determines if a controller is connected
  \return true if if a controller is connected
  */
  BOOL IsConnected();

  /**
  determines if a button is pressed
  \param button the gamepad button code representing the desired button
  \return true if the button is being held down
  */
  BOOL IsButtonDown(MGDFGamepadButton button);

  /**
  determines if a button is NOT pressed
  \param button the gamepad button code representing the desired button
  \return true if the button is not being pressed
  */
  BOOL IsButtonUp(MGDFGamepadButton button);

  /**
  determines if a button press has occured
  \param button the gamepad button code representing the desired button
  \return true if the button has been pressed (i.e pressed down then released)
  */
  BOOL IsButtonPress(MGDFGamepadButton button);

  /**
  returns the state of the controllers left trigger
  \return 0 for idle to 255 for fully held
  */
  UINT8 GetLeftTrigger();

  /**
  returns the state of the controllers right trigger
  \return 0 for idle to 255 for fully held
  */
  UINT8 GetRightTrigger();

  /**
  returns the state of the left thumbstick on the X axis
  \return -32768 for far left to +32767 for far right
  */
  INT32 GetLeftThumbX();

  /**
  returns the state of the left thumbstick on the Y axis
  \return -32768 for top to +32767 for bottom
  */
  INT32 GetLeftThumbY();

  /**
  returns the state of the right thumbstick on the X axis
  \return -32768 for far left to +32767 for far right
  */
  INT32 GetRightThumbX();

  /**
  returns the state of the right thumbstick on the Y axis
  \return -32768 for top to +32767 for bottom
  */
  INT32 GetRightThumbY();

  /**
  sets the vibration intensity in the left and right vibrator motors of the
  controller, valid values are 0-65535
  \param left the intensity of the left vibrator motor
  \param right the intensity of the right vibrator motor
  */
  void SetVibrationSpeed(UINT16 left, UINT16 right);
};

/**
Provides a means for modules to access information regarding user input
from the mouse, keyboard, and xinput controllers
*/
[
  uuid("98EC499D-5359-4902-8BA9-6E36686E9898"), object,
  local
] interface IMGDFInputManager : IUnknown {
  /**
  determines whether the OS cursor is displayed or not
  \param show Whether to show the cursor or not
  */
  void ShowCursor(BOOL show);

  /**
  determines if a key is presed
  \param key the Microsoft Virtual key code representing the desired key (see
  here for a list
  http://msdn.microsoft.com/en-us/library/windows/desktop/dd375731%28v=vs.85%29.aspx)
  \return true if the key is being held down
  */
  BOOL IsKeyDown(UINT16 key);

  /**
  determines if a key is NOT pressed
  \param key the Microsoft Virtual key code representing the desired key (see
  here for a list
  http://msdn.microsoft.com/en-us/library/windows/desktop/dd375731%28v=vs.85%29.aspx)
  \return true if the key is not being pressed
  */
  BOOL IsKeyUp(UINT16 key);

  /**
  determines if a keypress has occured
  \param key the Microsoft Virtual key code representing the desired key (see
  here for a list
  http://msdn.microsoft.com/en-us/library/windows/desktop/dd375731%28v=vs.85%29.aspx)
  \return true if the key has been pressed (i.e pressed down then released)
  */
  BOOL IsKeyPress(UINT16 key);

  /**
  get the x position of the mouse
  \return the x position of the mouse relative to the left of the screen in
  pixels
  */
  INT32 GetMouseX();

  /**
  get the y position of the mouse
  \return the y position of the mouse relative to the top of the screen in
  pixels
  */
  INT32 GetMouseY();

  /**
  get the x movement of the mouse in the current frame
  \return the x movement of the mouse in the current frame
  */
  INT32 GetMouseDX();

  /**
  get the y movement of the mouse in the current frame
  \return the y movement of the mouse in the current frame
  */
  INT32 GetMouseDY();

  /**
  get the position of the scroll wheel
  \return the change in position of the scroll wheel, this value will
  increment/decrement in divisions of 120 depending on direction
  */
  short GetMouseDZ();

  /**
  determine if a mouse button is down
  \param mouseButton the mousebutton code representing the desired button
  \return true if the button is held down
  */
  BOOL IsButtonDown(MGDFMouse mouseButton);

  /**
  determine if a mouse button is up
  \param mouseButton the mousebutton code representing the desired button
  \return true if the button is NOT held down
  */
  BOOL IsButtonUp(MGDFMouse mouseButton);

  /**
  determine if a mouse button was clicked
  \param mouseButton the mousebutton code representing the desired button
  \return true if the button has been clicked, i.e held down then released
  */
  BOOL IsButtonClicked(MGDFMouse mouseButton);

  /**
  get the maximum number of gamepads available (not all of them may be
  connected)
  \return the maximum number of gamepads available (not all of them
  may be connected)
  */
  UINT64 GetGamepadCount();

  /**
  gets a list of all compatible gamepads connected to the PC
  \param gamepads pointer to an array of gamepads (must be large enough to fit
  GetGamepadCount entries)
  */
  void GetGamepads([out] IMGDFGamepad * *gamepads);
};

/**
The logging levels available, LOG_ERROR is of the highest importance with
LOG_HIGH messages being of the least importance
*/
typedef enum MGDFLogLevel {
  MGDF_LOG_ERROR,
  MGDF_LOG_LOW,
  MGDF_LOG_MEDIUM,
  MGDF_LOG_HIGH
} MGDFLogLevel;

/**
 The MGDF logging system
 */
[
  uuid("B20785A5-B39E-494D-8D22-9FD0DAE1C4F9"), object,
  local
] interface IMGDFLogger : IUnknown {
  /**
   set the current logging verbosity level
   \param level the verbosity level
   */
  void SetLoggingLevel(MGDFLogLevel level);

  /**
   get the current logging verbosity level
   \return the current logging verbosity level
   */
  MGDFLogLevel GetLoggingLevel();

  /**
   write an entry to the log
   \param sender the location or component writing the log message
   \param message the content of the log message
   \param level the verbosity filter for writing out the message. The message
   will be written if this is less than or equal to the current logging level
   */
  void Log([in] const small *sender, [in] const small *message,
           MGDFLogLevel level);
};

/**
Allows a metric to be tagged with a collection of name/value pairs
*/
typedef struct MGDFTags {
  const small **Names;
  const small **Values;
  UINT64 Count;
} MGDFTags;

/**
 Allows recording of a metric value over time. These can then be exposed via the
 Prometheus metrics server endpoint when enabled
*/
[
  uuid("6BA6CD00-4B01-474E-BD98-7B8432B48D12"), object,
  local
] interface IMGDFMetric : IUnknown {
  /**
  records the latest value of the metric
  \param value the latest value of the metric
  \param tags any tags to identify with this recording of the metric, pass NULL if no tags are to be included
*/
  void Record([in] double value, [in] const MGDFTags *tags);
};

/**
 Tracks an interval of time being recorded by a performance counter. When
 released the timing recorded will be the duration of time between the scopes
 creation and release
*/
[
  uuid("6750875D-62A5-47FA-84C1-BF52430424B7"), object,
  local
] interface IMGDFPerformanceCounterScope : IUnknown{};

/**
 A names performance counter that can be used to time the duration of
 events. The results of these counters are shown in the MGDF debug overlay
 (press ALT-F12 to see in game)
 */
[
  uuid("E2E9FE7E-4D07-40FE-9858-8E583D73CB37"), object,
  local
] interface IMGDFPerformanceCounter : IUnknown {
  /**
   Gets the metric the counter updates
  \param metric the metric the counter updates
   */
  void GetMetric([out] IMGDFMetric * *metric);

  /**
   Begin timing by creating a performance counter scope. The timing is recorded
 at the point the scope is released
  \param tags any tags to identify with this counter, pass NULL if no tags are to be included
  \param scope points to the performance counter scope created
  \return S_OK if the the performance counter scope was created, otherwise will return an error code
   */
  HRESULT
  Begin([in] const MGDFTags *tags, [out] IMGDFPerformanceCounterScope **scope);

  /**
  Get the average value recorded by this timer
  \return the average value recorded by the timer
  */
  double GetAverageValue();
};

/**
 Provides an interface to the hosts high resolution CPU timer
 */
[
  uuid("4DA26ED2-514E-4CB2-B9D4-6AC4170DFDCE"), object,
  local
] interface IMGDFTimer : IUnknown {
  /**
  Get the current system time in ticks
  \return the current system time in ticks
  */
  LARGE_INTEGER GetCurrentTimeTicks();

  /**
  Get the current system timer frequency
  \return the current system timer frequency
  */
  LARGE_INTEGER GetTimerFrequency();

  /**
  Convert two system tick times into a duration in seconds
  \param newTime the newer of the two times
  \param oldTime the older of the two times
  \return the difference betweeen the two parameters converted into seconds
  */
  double ConvertDifferenceToSeconds(LARGE_INTEGER newTime,
                                    LARGE_INTEGER oldTime);
};

/**
The display settings for a particular display mode
*/
typedef struct MGDFDisplayMode {
  UINT32 Width;
  UINT32 Height;
  UINT32 RefreshRateNumerator;
  UINT32 RefreshRateDenominator;
  BOOL SupportsHDR;
  BOOL IsNativeSize;
} MGDFDisplayMode;

/**
The current fullscreen options
*/
typedef struct MGDFFullScreenDesc {
  BOOL FullScreen;
  BOOL ExclusiveMode;
} MGDFFullScreenDesc;

/**
Provides an interface for changing various rendering settings. Once released
the settings will be applied to the render system on the next frame
*/
[
  uuid("067B5F9F-AB09-45C8-8B0F-56C3ECB5E0A0"), object,
  local
] interface IMGDFPendingRenderSettingsChange : IUnknown {
  /**
  gets the number of frames that the swap chain is allowed to queue for
  rendering.
  \param frames the maximum number of frames that can be queued (1+)
  */
  void SetMaxFrameLatency(UINT32 frames);

  /**
  sets the current vsync setting
  \param vsync true if vsync is to be enabled
  */
  void SetVSync(BOOL vsync);

  /**
  sets the current fullscreen setting
  \param fullscreen a description of the desired fullscreen settings
  */
  void SetFullscreen(const MGDFFullScreenDesc *fullscreen);

  /**
  set the display devices current multisample level
  \param multisampleLevel the desired multisample level for the backbuffer
  \return returns false if the desired multisample level cannot be set.
  */
  BOOL SetBackBufferMultiSampleLevel(UINT32 multisampleLevel);

  /**
  set the desired multisample level for off screen render targets. This setting
  is not used directly by the framework but any client code should query this
  property when creating render targets that may require multisampling (see also
  \param multisampleLevel the desired multisample level for off screen render targets
  \return returns false if the desired multisample level cannot be set.
  */
  BOOL SetCurrentMultiSampleLevel(UINT32 multisampleLevel);

  /**
  sets the current display mode of the primary display output when running in
  exclusive fullscreen mode
  \param mode the display mode to use
  \return true if the display mode is supported and can be applied, false otherwise
  */
  BOOL SetCurrentDisplayMode([in] const MGDFDisplayMode *mode);

  /**
  sets the size of the window when running in windowed mode. While running in
  fullscreen, this function has no effect.
  \param width the width of the window
  \param height the height of the window
  */
  void SetWindowSize(UINT32 width, UINT32 height);

  /**
  sets whether HDR should be enabled when its supported by the current display
  output
  \param enabled whether HDR should be enabled
  */
  void SetHDREnabled(BOOL enabled);

  /**
  Cancels any pending changes
  */
  void Cancel();
};

/**
Provides an interface for getting and setting the hosts various display settings
*/
[
  uuid("BAF10DDF-1874-4299-A497-1F62C0691C8B"), object,
  local
] interface IMGDFRenderSettingsManager : IUnknown {
  /**
  gets the number of frames that the swap chain is allowed to queue for
  rendering.
  \return true if vsync is enabled
  */
  UINT32 GetMaxFrameLatency();

  /**
  gets the current vsync setting
  \return true if vsync is enabled
  */
  BOOL GetVSync();

  /**
  gets the current fullscreen setting
  \param fullscreen a description of the current fullscreen settings
  */
  void GetFullscreen([ in, out ] MGDFFullScreenDesc * fullscreen);

  /**
  get the number of supported multisample levels
  \return the number of supported multisample levels
  */
  UINT64 GetMultiSampleLevelCount();

  /**
  get the available multisample level supported by the display device at the
  given index ( 0 to GetMultiSampleLevelCount() - 1 )
  \param index the multisample index
  \param level returns the multisample level at the given index
  \return true if a supported multisample level is present at the given
  index, false otherwise.
  */
  BOOL GetMultiSampleLevel(UINT64 index, [out] UINT32 * level);

  /**
  get the current multisample level in use by the device
  \return the current multisample level in use by the device
  */
  UINT32 GetBackBufferMultiSampleLevel();

  /**
  get the current desired multisample level for off screen render targets
  \param quality if specified this parameter will be initialized with the
  maximum multisampling quality setting for the current multisample level
  \return the current desired multisample level for off screen render targets
  */
  UINT32 GetCurrentMultiSampleLevel([out] UINT32 * quality);

  /**
  get the number of supported display modes
  \return the number of supported display modes
  */
  UINT64 GetDisplayModeCount();

  /**
  get a supported display mode for the primary output at the given index (0 to
  GetDisplayModeCount - 1)
  \param index the display mode index
  \param mode will be set to the the display mode at the given index
  \return true if a display mode exists at a particular index
  */
  BOOL GetDisplayMode(UINT64 index, [ in, out ] MGDFDisplayMode * mode);

  /**
  get all the supported display modes for the primary output
  \param modes an array big enough to hold GetDisplayModeCount() modes
  */
  void GetDisplayModes([out] MGDFDisplayMode * *modes);

  /**
  get the display mode (if any) matching the requested width and height, if no
  matching display mode is found, false is returned. If HDR is enabled, and supported
  an HDR display mode will be preferentially chosen
  \param width the desired width of the display mode
  \param height the desired height of the display mode
  \param mode will be set to the matching display mode found (if any)
  \return true if a supported display mode exists for the given width and height
  */
  BOOL GetDisplayModeFromDimensions(UINT32 width, UINT32 height,
                                    [ in, out ] MGDFDisplayMode * mode);

  /**
  get the display mode matching the native width and height, of the primary
  output. If HDR is enabled, and supported an HDR display mode will be
  preferentially chosen
  \param mode will be set to the current display mode found
  \return true if a supported display mode exists for the native output width & height
  */
  BOOL GetNativeDisplayMode([ in, out ] MGDFDisplayMode * mode);

  /**
  get the current display mode for the primary output being used when running in
  exclusive fullscreen mode
  \param mode will be set to the current display mode being used.
  \return the current display mode being used (a pointer to mode)
  */
  MGDFDisplayMode *GetCurrentDisplayMode([ in, out ] MGDFDisplayMode * mode);

  /**
  get the current screen width, based on the current display mode in exclusive
  fullscreen, or on the window dimensions otherwise
  \return the current screen width
  */
  UINT32 GetScreenX();

  /**
  get the current screen height, based on the current display mode in
  exclusive fullscreen, or on the window dimensions otherwise
  \return thr current screen height
  */
  UINT32 GetScreenY();

  /**
  get whether HDR should be enabled when its supported by the current display
  output
  \return is hdr enabled
  */
  BOOL GetHDREnabled();

  /**
  get whether HDR is supported by the current display output. This can change
  from frame to frame, so shouldn't be cached.
  \return is hdr supported by the current display output
  */
  BOOL GetCurrentOutputHDRSupported();

  /**
  get the current SDR white level for the current display output. This can
  change from frame to frame, so shouldn't be cached.
  \return the SDR white level. To get value in nits use the following conversion (SDRWhiteLevel / 1000 ) * 80
  */
  ULONG GetCurrentOutputSDRWhiteLevel();

  /**
  get the DPI of the current display output. This can change from frame to
  frame, from frame to frame, so shouldn't be cached.
  \return the DPI of the current display output
  */
  UINT GetCurrentOutputDPI();

  /**
  Create a pending changeset to the render settings
  */
  void CreatePendingSettingsChange([out] IMGDFPendingRenderSettingsChange *
                                   *changeset);

  /**
  Gets the current persistable render settings.
  \param preferences a pointer to a preference set that can be passed into the
  IMGDFGame SetPreferences method to set the preferences
  */
  void GetPreferences([out] IMGDFPreferenceSet * *preferences);
};

/**
 Provides an interface for reading data from a file
 */
[
  uuid("3C07D9A2-D197-4CDC-9DF6-3D244B854FB1"), object,
  local
] interface IMGDFFileReader : IUnknown {
  /**
  reads the specified number of bytes into the buffer
  \param buffer a buffer to store the read data
  \param length the max amount of data that can be read into the buffer
  \return the amount of bytes actually read into the buffer
  */
  UINT32 Read([out] void *buffer, UINT32 length);

  /**
  sets the read position of the file in bytes
  \param pos the read position of the file in bytes
  */
  void SetPosition(INT64 pos);

  /**
  get the current read position of the file in bytes
  \return the read position in the file
  */
  INT64 GetPosition();

  /**
  determines whether the file read position has reached the end of the file
  \return true if the read position is past the end of the file
  */
  BOOL EndOfFile();

  /**
  get the size of the file in bytes
  \return the filesize in bytes (for compressed archives this value is the
  uncompressed size)
  */
  INT64 GetSize();
};

/**
 Provides an interface for writing data to a file
 */
[
  uuid("46A8D28E-CE6A-4E99-BACF-AF9947008FA0"), object,
  local
] interface IMGDFFileWriter : IUnknown {
  /**
  writes the specified number of bytes into the buffer
  \param buffer a buffer to store the write data
  \param length the max amount of data to write to the file
  \return the amount of bytes actually written to the file
  */
  UINT32 Write([out] void *buffer, UINT32 length);

  /**
  sets the write position of the file in bytes
  \param pos the write position of the file in bytes
  */
  void SetPosition(INT64 pos);

  /**
  get the current write position of the file in bytes
  \return the write position in the file
  */
  INT64 GetPosition();
};

/**
Provides a base interface for filesystem access that is common across the
readonly virtual filesystem and writeable save and working directories.
*/
[
  uuid("7EB85F59-65C6-45AC-B505-F263E1771C7F"), object,
  local
] interface IMGDFFile : IUnknown {
  /**
  Get how many children this file has
  \return how many children this file has
  */
  UINT64 GetChildCount();

  /**
  determines if the file entity is a folder
  \return true if the file is a folder
  */
  BOOL IsFolder();

  /**
  determines if the file has an open reader
  \return true if the file has an open reader
  */
  BOOL IsOpen();

  /**
  attempt to open the file for reading. Only one fileReader can be open for a
  file at any time. Because of this, you should ensure that any reader is closed
  after it is no longer needed.
  \param reader pointer to any reader that is created
  \return S_OK if the reader was created, E_FAIL if the file could not be opened or
  E_ACCESSDENIED if it was already open
  */
  HRESULT Open([out] IMGDFFileReader * *reader);

  /**
  find the last write time of the file
  \return a timestamp indicating the last write time
  */
  UINT64 GetLastWriteTime();

  /**
  Gets the physical name of this file on disk
  \param name buffer to store the file name
  \param length the length of the buffer provided to store the value above. Will be set to the length required
  \return S_OK if the buffer was the correct length otherwise E_FAIL
  */
  HRESULT GetPhysicalName([ in, out ] wchar_t * name,
                          [ in, out ] UINT64 * length);

  /**
  Gets the physical path to this file
  \param name buffer to store the file path
  \param length the length of the buffer provided to store the value above. Will be set to the length required
  \return S_OK if the buffer was the correct length otherwise E_FAIL
  */
  HRESULT GetPhysicalPath([ in, out ] wchar_t * name,
                          [ in, out ] UINT64 * length);

  /**
  Gets the logical name of this file
  \param name buffer to store the file name
  \param length the length of the buffer provided to store the value above. Will be set to the length required
  \return S_OK if the buffer was the correct length otherwise E_FAIL
  */
  HRESULT GetLogicalName([ in, out ] wchar_t * name,
                         [ in, out ] UINT64 * length);

  /**
  Gets the logical path to this file
  \param name buffer to store the file name
  \param length the length of the buffer provided to store the value above. Will be set to the length required
  \return S_OK if the buffer was the correct length otherwise E_FAIL
  */
  HRESULT GetLogicalPath([ in, out ] wchar_t * name,
                         [ in, out ] UINT64 * length);
};

interface IMGDFWriteableVirtualFileSystem;

/**
Provides an interface for navigating a writeable file/directory structure. These
include writeable folders such as the working directory and save game folders.
*/
[
  uuid("8B17D0A7-9A51-4D28-A5A2-84F38CD5A86E"), object,
  local
] interface IMGDFWriteableFile : IMGDFFile {
  /**
  Does the file/folder exist
  \return true if the file/folder exists
  */
  BOOL Exists();

  /**
  Gets the parent of this file. If this file is the root of the virtual
  filesystem, then this will be nullptr
  \param parent pointer to the parent of this file.
  \return If this file is the root of the filesystem then return false, otherwise true.
  */
  BOOL GetParent(IMGDFWriteableFile * *parent);

  /**
  Gets a child of this file with the given name (if any)
  \param name the child name of this file
  \param child the child file of the current file
  \return S_OK if the child file could be found, E_FAIL otherwise
  */
  HRESULT GetChild([in] const wchar_t *name, [out] IMGDFWriteableFile **child);

  /**
   Get all the children of this file (non-recursive)
   \param childBuffer an array to store the results (must be large enough to
   hold GetChildCount entries)
   \return S_OK if all the children could be stored in the provided buffer
   */
  HRESULT GetAllChildren([out] IMGDFWriteableFile * *childBuffer);

  /**
  attempt to open the file for writing if the path to this file doesn't exist
  it will be created
  \param writer pointer to a writer instance to be created
  \return S_OK if the writer could be created, otherwise E_FAIL or E_ACCESSDENIED
  */
  HRESULT OpenWrite([out] IMGDFFileWriter * *writer);

  /**
  creates this as a folder (and any necessary parent folders along the way)
  \return S_OK if the folder could be created, otherwise E_FAIL
  */
  HRESULT CreateFolder();

  /**
  deletes this file or folder (and its descendants). Note the root of a VFS
  cannot be deleted and will fail if attempted
  \return S_OK if the file or folder could be deleted, otherwise E_FAIL
  */
  HRESULT Delete();

  /**
  moves this file or folder to the desired target location
  \param destination the target location for this file/folder. If the destination exists
  it should be deleted first or else this call will fail.
  \return S_OK if the file/folder could be moved, otherwise E_FAIL
  */
  HRESULT MoveTo([in] IMGDFWriteableFile * destination);

  /**
  copies this file or folder to the desired target location
  \param destination the target location for this file/folder. If the destination exists
  it should be deleted first or else this call will fail.
  \return S_OK if the file/folder could be copied, otherwise E_FAIL
  */
  HRESULT CopyTo([in] IMGDFWriteableFile * destination);

  /**
  Get the virtual filesystem this file belongs to
  \param vfs the virtual filesystem this file belongs to
  */
  void GetVFS([out] IMGDFWriteableVirtualFileSystem * *vfs);
};

interface IMGDFReadOnlyVirtualFileSystem;

/**
Provides an interface for navigating a readonly file/directory structure in the
virtual filesystem. Directories have no data but can have subfiles Files have no
subfiles (except for archives) but may have data. Archives that have been added
to the vfs are mapped as files with the same name as the archive filename, but
unlike normal files they also have a tree of subdirectories containing the
uncompressed archive data
*/
[
  uuid("D7F3A3C2-BEDB-4C20-8DD6-452793A11BE1"), object,
  local
] interface IMGDFReadOnlyFile : IMGDFFile {
  /**
  Gets the parent of this file. If this file is the root of the virtual
  filesystem, then this will be nullptr
  \param parent pointer to the parent of this file.
  \return If this file is the root of the filesystem, then return false
  */
  BOOL GetParent(IMGDFReadOnlyFile * *parent);

  /**
  Gets a child of this file with the given name (if any)
  \param name the child name of this file
  \param child the child file of the current file. If no such file exists, nullptr is
  returned
  \return true if the child could be found
  */
  BOOL GetChild([in] const wchar_t *name, [out] IMGDFReadOnlyFile **child);

  /**
   Get all the children of this file (non-recursive)
   \param childBuffer an array to store the results (must be large enough to
   hold GetChildCount entries)
   */
  void GetAllChildren([out] IMGDFReadOnlyFile * *childBuffer);

  /**
  determines if the file is a (or is a member of) an archive file
  \return true if the file is a (or is a member of) an archive file
  */
  BOOL IsArchive();

  /**
  Get the virtual filesystem this file belongs to
  \param vfs the virtual filesystem this file belongs to
  */
  void GetVFS([out] IMGDFReadOnlyVirtualFileSystem * *vfs);

  /**
  copies this file or folder to the desired writeable target location
  \param destination the target location for this file/folder. If the destination exists
  it should be deleted first or else this call will fail.
  \return S_OK if the file/folder could be copied, otherwise E_FAIL
  */
  HRESULT CopyTo([in] IMGDFWriteableFile * destination);
};

/**
Provides an interface for creating portions of the vfs tree from archive files
*/
[
  uuid("09A21A95-9E64-4CCE-8CA3-CD938D94DD4D"), object,
  local
] interface IMGDFArchiveHandler : IUnknown {
  /**
  get the root node of the mapped vfs subtree
  \param name the name of the archive
  \param physicalPath the physical path on disk containing the archive
  \param parent the VFS parent node of the archive
  \param vfs the VFS the archive will belong to
  \param root pointer to the root node of the mapped vfs subtree
  \return S_OK if the archive could be mapped correctly, otherwise E_FAIL
  */
  HRESULT
  MapArchive([in] const wchar_t *name, [in] const wchar_t *physicalPath,
             [in] IMGDFReadOnlyFile *parent,
             [in] IMGDFReadOnlyVirtualFileSystem *vfs,
             [out] IMGDFReadOnlyFile **root);

  /**
  whether this file/directory is recognised as an archive type
  \param physicalPath the physical path on disk of a possible achive file
  \return true if the file is a recognized archive file to be handled by this
  handler
  */
  BOOL IsArchive([in] const wchar_t *physicalPath);
};

/**
Provides an interface for accessing the readonly filesystem, which is a fast
read only interface to access game content files. The root MGDF filesystem is
mounted from the game/content folder.
*/
[
  uuid("235AB71E-BAE5-4ACB-BA98-82086378C939"), object,
  local
] interface IMGDFReadOnlyVirtualFileSystem : IUnknown {
  /**
  Get the file/folder/archive in the specified logical directory. paths are
  delimited using the / character and names are case sensitive. The
  /game/content folder in the MGDF install root folder is mounted as the root of
  the logical filesystem, and no access outside of this folder is permitted.
  \param logicalPath the vfs path to the file
  \param file pointer to the file/folder/archive in the specified logical directory. paths
  are delimited using the / character and names are case sensitive
  \return true if the file could be found
  */
  BOOL GetFile([in] const wchar_t *logicalPath, [out] IMGDFReadOnlyFile **file);

  /**
  Get the root node of the filesystem. In the physical filesystem this
  corresponds to the /game/content folder.
  \param root pointer to the root node of the filesystem
  */
  void GetRoot([out] IMGDFReadOnlyFile * *root);

  /**
  Get the logical path to a file
  \param file the file to get the logical path to
  \param path buffer to store the logical path
  \param length the length of the buffer provided to store the value above. Will be set to the length required
  \return S_OK if the buffer was the correct length otherwise E_FAIL
  */
  HRESULT GetLogicalPath(IMGDFReadOnlyFile * file, wchar_t * path,
                         UINT64 * length);
};

/**
Provides an interface for accessing the writable filesystem, which is used for
save game folders and the working directory
*/
[
  uuid("2EAC465E-F424-43EB-AEE8-EA930215A811"), object,
  local
] interface IMGDFWriteableVirtualFileSystem : IUnknown {
  /**
  Get the file/folder/archive in the specified logical directory. paths are
  delimited using the / character and names are case sensitive.
  \param logicalPath the vfs path to the file
  \param file pointer to the file/folder/archive in the specified logical directory. paths
  are delimited using the / character and names are case sensitive
  \return true if the file could be found
  */
  BOOL
  GetFile([in] const wchar_t *logicalPath, [out] IMGDFWriteableFile **file);

  /**
  Get the root node of the filesystem. In the physical filesystem this
  corresponds to the /game/content folder.
  \param root pointer to the root node of the filesystem
  */
  void GetRoot([out] IMGDFWriteableFile * *root);

  /**
  Get the logical path to a file
  \param file the file to get the logical path to
  \param path buffer to store the logical path
  \param length the length of the buffer provided to store the value above. Will be set to the length required
  \return S_OK if the buffer was the correct length otherwise E_FAIL
  */
  HRESULT GetLogicalPath(IMGDFWriteableFile * file, wchar_t * path,
                         UINT64 * length);
};

/**
The position of a sound source in 3d space
*/
typedef struct MGDFSoundPosition {
  float x, y, z;
} MGDFSoundPosition;

/**
An sound source in 3d space
*/
[
  uuid("EBCC1B73-815F-4870-BC80-67A5379E65FC"), object,
  local
] interface IMGDFSound : IUnknown {
  /**
  The name of the sound
  \param name buffer to store the sound name
  \param length the length of the buffer provided to store the value above. Will be set to the length required
  \return S_OK if the buffer was the correct length otherwise E_FAIL
  */
  HRESULT GetName([ in, out ] wchar_t * name, [ in, out ] UINT64 * length);

  /**
  The position of the sound
  \param position the position of the sound
  \return the position of the sound
  */
  MGDFSoundPosition *GetPosition(MGDFSoundPosition * position);

  /**
  The velocity of the sound
  \param velocity the velocity of the sound
  \return the velocity of the sound
  */
  MGDFSoundPosition *GetVelocity(MGDFSoundPosition * velocity);

  /**
  Set the position of the sound
  \param position the position of the sound
  \return the position of the sound
  */
  MGDFSoundPosition *SetPosition(MGDFSoundPosition * position);

  /**
  Set the velocity of the sound
  \param velocity the velocity of the sound
  \return the velocity of the sound
  */
  MGDFSoundPosition *SetVelocity(MGDFSoundPosition * velocity);

  /**
  The distance (from the observer) at which the sound intensity reaches its
  maximum. Getting closer than this will not cause the sound intensity to get
  any greater \return The distance (from the observer) at which the sound
  intensity reaches its maximum. Getting closer than this will not cause the
  sound intensity to get any greater
   */
  float GetInnerRange();

  /**
   Set The distance (from the observer) at which the sound intensity reaches its
   maximum. Getting closer than this will not cause the sound intensity to get
   any greater
   \param innerRange The distance (from the observer) at which the
   sound intensity reaches its maximum. Getting closer than this will not cause
   the sound intensity to get any greater
   */
  void SetInnerRange(float innerRange);

  /**
  The distance (from the observer) at which the sound intensity reaches 0
  \return The distance (from the observer) at which the sound intensity reaches
  its 0
   */
  float GetOuterRange();

  /**
   Set The distance (from the observer) at which the sound intensity reaches 0
   \param outerRange The distance (from the observer) at which the sound
   intensity reaches 0
   */
  void SetOuterRange(float outerRange);

  /**
   Does the sound stay relative to the listeners position or is it fixed in
   absolute space
   \return true if the sound is always relative to the listeners
   position
   */
  BOOL GetSourceRelative();

  /**
   Does the sound stay relative to the listeners position or is it fixed in
   absolute space
   \param sourceRelative true if the sound is always relative to
   the listeners position
   */
  void SetSourceRelative(BOOL sourceRelative);

  /**
  Get the current volume of the sound (ignoring attenuation due to position)
  \return the current volume of the sound (ignoring attenuation due to position)
  */
  float GetVolume();

  /**
  Set the current volume of the sound (ignoring attenuation due to position)
  \param volume the current volume of the sound (ignoring attenuation due to
  position)
  */
  void SetVolume(float volume);

  /**
  Get the pitch of the current sound
  \return 1.0 if the pitch is unchanged. between 0.5 and 1.0 is lower, and
  between 1.0 and 2.0 is higher pitched
  */
  float GetPitch();

  /**
  Set the pitch of the current sound
  \param pitch 1.0 if the pitch is unchanged. between 0.5 and 1.0 is lower, and
  between 1.0 and 2.0 is higher pitched
  */
  void SetPitch(float pitch);

  /**
  Set the priority used by the sound system to determine which sounds get
  deactivated if not enough sound sources are available to play all sounds
  \param priority the priority to use for the sound. Higher values mean higher
  priority
  */
  void SetPriority(INT32 priority);

  /**
  Get the priority used by the sound system to determine which sounds get
  deactivated if not enough sound sources are available to play all sounds
  \return priority the priority to use for the sound. Higher values mean higher
  priority
  */
  INT32 GetPriority();

  /**
   Get whether the sound will loop playback continously
   \return true if the sound should loop continously
   */
  BOOL GetLooping();

  /**
   Set whether the sound will loop playback continously
   \param looping true if the sound should loop playback, false otherwise
   \return looping true if the sound should loop continously
   */
  void SetLooping(BOOL looping);

  /**
  stop the playing of the current playlist if it was playing or paused (resets
  playlist to the beginning aswell)
  */
  void Stop();

  /**
  pause the playing of the current playlist (if it was playing)
  */
  void Pause();

  /**
  resume the playing of the current playlist (if it was paused or stopped)
  */
  void Play();

  /**
  determines if the playlist has stopped play
  \return true if the playlist has stopped play
  */
  BOOL IsStopped();

  /**
  determines if the playlist has paused play
  \return true if the playlist has paused play
  */
  BOOL IsPaused();

  /**
  determines if the playlist is playing
  \return true if the playlist is playing
  */
  BOOL IsPlaying();

  /**
  Is the sound currently playing or has it been culled
  \return true if the sound manager has culled this sound source
  */
  BOOL IsActive();
};

/**
A vorbis sound stream
*/
[
  uuid("2F0555E6-B5C3-40C4-9399-F74699A38811"), object,
  local
] interface IMGDFSoundStream : IUnknown {
  /**
  The name of the sound stream
  \param name buffer to store the sound stream name
  \param length the length of the buffer provided to store the value above. Will be set to the length required
  \return S_OK if the buffer was the correct length otherwise E_FAIL
  */
  HRESULT GetName([ in, out ] wchar_t * name, [ in, out ] UINT64 * length);

  /**
  Get the volume level (0-1)
  \return The volume level (0-1)
  */
  float GetVolume();

  /**
  Set the volume level (0-1)
  \param volume the volume level to set
  */
  void SetVolume(float volume);

  /**
  The position of playback in the stream (0 -> GetLength)
  \return The position of playback in the stream
  */
  UINT32 GetPosition();

  /**
  The total length of the stream
  \return The total length of the stream
  */
  UINT32 GetLength();

  /**
  stop the playing of the current stream if it was playing or paused (resets it
  to the beginning aswell)
  */
  void Stop();

  /**
  pause the playing of the current stream (if it was playing)
  */
  void Pause();

  /**
  resume the playing of the current playlist (if it was paused or stopped)
  \return success if the sound could resume playing, otherwise returns an error
  code.
  */
  HRESULT Play();

  /**
  determines if the stream has stopped play
  \return true if the stream has stopped play
  */
  BOOL IsStopped();

  /**
  determines if the stream has paused play
  \return true if the stream has paused play
  */
  BOOL IsPaused();

  /**
  determines if the stream is playing
  \return true if the stream is playing
  */
  BOOL IsPlaying();
};

/**
 An interface for controlling positional sounds as well as streaming sound
 sources
*/
[
  uuid("1E14DC82-8588-4686-888A-149993E4AE9B"), object,
  local
] interface IMGDFSoundManager : IUnknown {
  /**
  determine the position of the listener (i.e. the player)
  \param listener the position of the listener (i.e. the player)
  \return the position of the listener (i.e. the player)
  */
  MGDFSoundPosition *GetListenerPosition(MGDFSoundPosition * listener);

  /**
  determine the velocity of the listener (i.e. the player)
  \param velocity the velocity of the listener (i.e. the player)
  \return the velocity of the listener (i.e. the player)
  */
  MGDFSoundPosition *GetListenerVelocity(MGDFSoundPosition * velocity);

  /**
   Get the vector representing the forward direction of the listener (i.e. the
   player)
   \param orientationForward the vector representing the forward direction of the listener
   \return the vector representing the forward direction of the listener
  */
  MGDFSoundPosition *GetListenerOrientationForward(MGDFSoundPosition *
                                                   orientationForward);

  /**
   Get the vector representing the upward direction of the listener (i.e. the
   player)
   \param orientationUp the vector representing the upward direction of the listener
   \return the vector representing the upward direction of the listener
   */
  MGDFSoundPosition *GetListenerOrientationUp(MGDFSoundPosition *
                                              orientationUp);

  /**
  set the position of the listener (i.e. the player)
  \param listener the position of the listener (i.e. the player)
  \return the position of the listener (i.e. the player)
  */
  MGDFSoundPosition *SetListenerPosition(MGDFSoundPosition * listener);

  /**
  set the velocity of the listener (i.e. the player)
  \param velocity the velocity of the listener (i.e. the player)
  \return the velocity of the listener (i.e. the player)
  */
  MGDFSoundPosition *SetListenerVelocity(MGDFSoundPosition * velocity);

  /**
   set the vector representing the forward direction of the listener (i.e. the
   player)
   \param orientationForward the vector representing the forward direction of
  the listener
   \return the vector representing the forward direction of the listener
   */
  MGDFSoundPosition *SetListenerOrientationForward(MGDFSoundPosition *
                                                   orientationForward);

  /**
   set the vector representing the upward direction of the listener (i.e. the
   player)
   \param orientationUp the vector representing the upward direction of the listener
   \return the vector representing the upward direction of the listener
   */
  MGDFSoundPosition *SetListenerOrientationUp(MGDFSoundPosition *
                                              orientationUp);

  /**
  Get the master volume (0-1) All sounds volumes are relative to this setting
  \return the master volume
  */
  float GetSoundVolume();

  /**
  Set the master volume (0-1) All sounds volumes are relative to this setting
  \param volume the master volume
  */
  void SetSoundVolume(float volume);

  /**
  Get the master volume for streamed sounds (0-1) All streams volumes are
  relative to this setting \return the master stream volume
  */
  float GetStreamVolume();

  /**
  Set the master volume for streamed sounds (0-1) All streams volumes are
  relative to this setting \param volume the master stream volume
  */
  void SetStreamVolume(float volume);

  /**
  Get whether sounds should attenuate with thier distance from the listener
  \return true if sounds should attenuate with thier distance from the listener
  */
  BOOL GetEnableAttenuation();

  /**
  Set whether sounds should attenuate with thier distance from the listener
  \param enableAttenuation true if sounds should attenuate with thier distance
  from the listener
  */
  void SetEnableAttenuation(BOOL enableAttenuation);

  /**
  Get whether sounds will doppler shift based on thier relative velocity to the
  listener
  \return whether sounds will doppler shift based on thier relative velocity to the listener
  */
  float GetDopplerShiftFactor();

  /**
  Set whether sounds will doppler shift based on thier relative velocity to the
  listener
  \param dopplerShiftFactor true if sounds should doppler shift based
  on thier relative velocity to the listener
  */
  void SetDopplerShiftFactor(float dopplerShiftFactor);

  /**
  Get the speed of sound used to calculate doppler shifting of sounds
  \return the speed of sound used to calculate doppler shifting of sounds
  */
  float GetSpeedOfSound();

  /**
  Set the speed of sound used to calculate doppler shifting of sounds
  \param speedOfSound the speed of sound used to calculate doppler shifting of
  sounds
  */
  void SetSpeedOfSound(float speedOfSound);

  /**
  create a sound by loading a file in the VFS into memory. When no INT32er used
  it should be Released
  \param file the data source for the sound
  \param priority the priority of the sound (used to determine what should play if no
  free audio sources are available
  \param sound If the sound is created successfully, this will point to the created sound
  \return S_OK if the sound was created successfully, otherwise an error code will be returned
  */
  HRESULT CreateSound([in] IMGDFReadOnlyFile * file,
                      INT32 priority, [out] IMGDFSound * *sound);

  /**
  create a sound stream from a file in the VFS. When no longer used it should be
  Released
  \param file the data source for the sound stream
  \param stream If the stream is created successfully, this will point to the created stream
  \return S_OK if the stream was created successfully, otherwise an error code will
  be returned
  */
  HRESULT
  CreateSoundStream([in] IMGDFReadOnlyFile * file, [out] IMGDFSoundStream *
                                                       *stream);

  /**
  Gets the current persistable sound settings. Note: this only consists of
  master volume settings. Other settings like attenuation & speedOfSound need to
  be reset on startup
  \param preferences a pointer to a preference set that can be passed into the
  IMGDFGame setPreferences method to set the preferences
  */
  void GetPreferences([out] IMGDFPreferenceSet * *preferences);
};

/**
 Provides an interface for pushing statistics to a remote endpoint during a game
 session.
 */
[
  uuid("F809B9CB-AE6B-43EE-8ACC-40BCB11014E1"), object,
  local
] interface IMGDFStatisticsManager : IUnknown {
  /**
   Pushes a statistic to the remote statistics service (if one is specified)
   \param name the name of the statistic tracker key
   \param value the value of the statistic
   \param tags any tags to pass with the statistic (null if none are to be included)
   */
  void PushString([in] const small *name, [in] const small *value,
                  [in] const MGDFTags *tags);

  /**
   Pushes a metrics current value to the remote statistics service (if one is
   specified)
   \param metric the metric to push, this will be passed to the statistics service as a name/value pair
   */
  void PushMetric([in] IMGDFMetric * metric);
};

/**
Provides an entrypoint for a module to interact with the MGDF host. Methods in
this interface are safe to be used from any thread
*/
[
  uuid("B6FDBA44-D098-4EF7-AF79-7368FB85AA6C"), object,
  local
] interface IMGDFCommonHost : IMGDFLogger {
  /**
   * This method should be invoked when a fatal error is encountered
   * \param sender the location or component the error occurred in
   * \param message details of the fatal error
   */
  void FatalError([in] const small *sender, [in] const small *message);

  /**
  get the render settings manager
  \param settings the render settings manager
  */
  void GetRenderSettings([out] IMGDFRenderSettingsManager * *settings);

  /**
  get the host timer
  \param timer pointer to the host timer
  */
  void GetTimer([out] IMGDFTimer * *timer);

  /**
  gets the current version of the framework
  \return the current version of the framework
  */
  const MGDFVersion *GetMGDFVersion();

  /**
  get the readonly content filesystem
  \param vfs the readonly filesystem
  */
  void GetVFS([out] IMGDFReadOnlyVirtualFileSystem * *vfs);

  /**
  get the read/write working folder
  \param vfs the writeable filesystem
  */
  void GetWorkingVFS([out] IMGDFWriteableVirtualFileSystem * *vfs);

  /**
  get the direct3d device object from the host
  \param device the direct3d device object from the host
  */
  void GetD3DDevice([out] ID3D11Device * *device);

  /**
  get the direct2d device object from the host
  \param device the direct2d device object from the host
  */
  void GetD2DDevice([out] ID2D1Device * *device);

  /**
  get the onscreen debug overlay interface
  \param debug pointer to a debug overlay object
  */
  void GetDebug([out] IMGDFDebug * *debug);

  /**
   create a performance counter for profiling CPU time taken. When no longer
   used it should be released
  \param metric the metric the counter should update
  \param counter points to the created counter
  \return S_OK if the counter could be created, otherwise an error code is returned
   */
  HRESULT CreateCPUCounter([in] IMGDFMetric * metric,
                           [out] IMGDFPerformanceCounter * *counter);

  /**
  create or get an existing metric for a monotonically increasing counter
  \param name the name of the metric
  \param description a description of what the metric is measuring
  \param metric points to the created metric
  \return S_OK if the metric could be created, otherwise an error code is returned
  */
  HRESULT
  CreateCounterMetric([in] const small *name, [in] const small *description,
                      [out] IMGDFMetric **metric);

  /**
  create or get an existing metric that can go up and down over time
  \param name the name of the metric
  \param description a description of what the metric is measuring
  \param metric points to the created metric
  \return S_OK if the metric could be created, otherwise an error code is returned
  */
  HRESULT
  CreateGaugeMetric([in] const small *name, [in] const small *description,
                    [out] IMGDFMetric **metric);

  /**
  create or get an existing metric that can go up and down over time
  \param name the name of the metric
  \param description a description of what the metric is measuring
  \param buckets pointer to an array of buckets used in the histogram
  \param bucketCount the length of the buckets array parameter
  \param metric points to the created metric
  \return S_OK if the metric could be created, otherwise an error code is returned
  */
  HRESULT CreateHistogramMetric(
      [in] const small *name, [in] const small *description,
      [in] const double *buckets, [in] const UINT64 bucketCount,
      [out] IMGDFMetric **metric);

  /**
  After a module receives an RTOnBeforeDeviceReset callback, calling this tells
  the host that all references to the previous D3D device have been cleaned up
  and that the device can be safely reset
  */
  void QueueDeviceReset();
};

/**
 Provides an entrypoint for a module to interact with the MGDF host. This
 interface inherits from ICommonHost and provides additional methods which are
 safe to be used ONLY from the render thread.
*/
[
  uuid("514EBD97-3C53-4235-90E1-7AD3B7F517BD"), object,
  local
] interface IMGDFRenderHost : IMGDFCommonHost {
  /**
  set the current back buffer as the render target for the specified d2d device
  context
  \param context the d2d device context to set the render target for
  \return true if the back buffer can be set as the render target for the device
  context
  */
  BOOL SetBackBufferRenderTarget(ID2D1DeviceContext * context);

  /**
  Gets the current back buffer texture.
  \param backbuffer the current back buffer texture. The pointer returned by this method
  becomes invalid when the modules OnReset event is fired
  */
  void GetBackBuffer([out] ID3D11Texture2D * *backbuffer);

  /**
  Gets the current depth stencil buffer texture.
  \param stencilBuffer the current stencil buffer texture. The pointer returned by this method
  becomes invalid when the modules OnReset event is fired
  */
  void GetDepthStencilBuffer([out] ID3D11Texture2D * *stencilBuffer);

  /**
  Gets the description of the backbuffer and depthStencilBuffer textures.
  \param backBufferDesc the backbuffer description to populate. If null is
  passed, this field is not populated
  \param depthStencilBufferDesc the backbuffer description to populate. If
  null is passed, this field is not populated
  */
  void GetBackBufferDescription(D3D11_TEXTURE2D_DESC * backBufferDesc,
                                D3D11_TEXTURE2D_DESC * depthStencilBufferDesc);

  /**
   create a performance counter for profiling GPU time taken in DirectX API
   calls. When no longer used it should be Released
   \param metric the metric the counter should update
   \param context the device context this counter measures
   \param counter points to the created counter
   \return E_FAIL if GPU counters are unsupported (using D3D_FEATURE_LEVEL_9_3 or less)
   otherwise returns S_OK
   */
  HRESULT CreateGPUCounter([in] IMGDFMetric * metric,
                           [in] ID3D11DeviceContext * context,
                           [out] IMGDFPerformanceCounter * *counter);
};

/**
 A saved game state and its associated metadata
*/
[
  uuid("B34FC7A2-2F84-4FC7-B821-4AEDA8AB9F20"), object,
  local
] interface IMGDFGameState : IUnknown {
  /**
  Gets the value of a metadata key
  \param key the name of the metadata key
  \param value buffer to store the value associated with the key or nullptr if there is no such key
  \param length the length of the buffer provided to store the value above. Will be set to the length required
  \return S_OK if the value was found and the buffer was the correct length otherwise E_FAIL
  */
  HRESULT GetMetadata([in] const small *key, [ in, out ] small *value,
                      [ in, out ] UINT64 *length);

  /**
  Sets the value of a metadata key
  \param key the name of the metadata key
  \param value the value associated with the key
  \return S_OK if the value could be stored
  */
  HRESULT SetMetadata([ in, out ] const small *key,
                      [ in, out ] const small *value);

  /**
  Is this a new game state with no persisted data that has been created from a
  recent call to CreateGameState
  \return true if the game state is new with no persisted data
  */
  BOOL IsNew();

  /**
  Get the version of the Module that saved this game state
  \param version the version of the Module that saved this game state
  */
  void GetVersion([ in, out ] MGDFVersion * version);

  /**
  Get the readonly virtual filesystem for the game states previously persisted
  data.
  \param vfs the virtual filesystem for accessing the game states data
  \return S_OK if the virtual filesystem could be mounted, will fail if the game state is new
  */
  HRESULT GetVFS([out] IMGDFReadOnlyVirtualFileSystem * *vfs);

  /**
  Begins the process of saving the gamestate data. Once finished saving all data
  to the VFS
  instance returned. Modules should release the VFS to commit the save
  \param pending A VFS mounted in a temporary save directory, once released any data in this
  directory will be copied into the permanent game state data directory
  \return S_OK if the VFS could be mounted
  */
  HRESULT BeginSave([out] IMGDFWriteableVirtualFileSystem * *pending);
};

/**
An interface to control saving/loading gamestate data
*/
[
  uuid("58D65D58-358D-4999-B32C-F32CF0B0AC83"), object,
  local
] interface IMGDFSaveManager : IUnknown {
  /**
  Get the number of saved gamestates available
  \return the number of saved gamestates available
  */
  UINT64 GetSaveCount();

  /**
  Get the saved state at the given index.
  \param index which gamestate, valid values are 0 to GetSaveCount - 1.
  \param save pointer to the gamestate at the given index
  \return S_OK if a valid gamestate exists at the given index, otherwise an error code is returned
  */
  HRESULT GetSave(UINT64 index, [out] IMGDFGameState * *save);

  /**
  Deletes a saved gamestate
  \param state a gamestate previously returned from GetSave
  \return S_OK if the gamestate could be deleted, otherwise an error code is returned
  */
  HRESULT DeleteSave([out] IMGDFGameState * state);

  /**
  Creates a new empty gamestate without metadata or any persisted data
  \param save a pointer to the created gamestate.
  */
  void CreateGameState([out] IMGDFGameState * *save);
};

/**
Provides an entrypoint for a module to interact with the MGDF host. This
interface inherits from IMGDFCommonHost and provides additional methods which
are safe to be used ONLY from the sim thread.
*/
[
  uuid("381AD5F1-8058-4739-992F-A5B551AA0E87"), object,
  local
] interface IMGDFSimHost : IMGDFCommonHost {
  /**
  Gets the save manager
  \param save the save manager object
  */
  void GetSaves([out] IMGDFSaveManager * *save);

  /**
  get information regarding the current game and its preferences
  \param game pointer to object containing information regarding the game and its preferences
  */
  void GetGame([out] IMGDFGame * *game);

  /**
  get the sound manager
  \param sound the sound manager, nullptr if the audio subsystem failed to
  initialize
  */
  void GetSound([out] IMGDFSoundManager * *sound);

  /**
  get the statistics manager
  \param statistics the statistics manager
  */
  void GetStatistics([out] IMGDFStatisticsManager * *statistics);

  /**
  get the input manager
  \param input pointer to an input manager
  */
  void GetInput([out] IMGDFInputManager * *input);

  /**
  tells the host to shut down the game immediately
  */
  void ShutDown();

  /**
  tells the host to invoke the modules shutdown callback
  */
  void QueueShutDown();
};

/**
 The interface to be implemented by an MGDF game
*/
[
  uuid("08D1F4AD-366B-4659-B4A6-AA04B458D6DB"), object,
  local
] interface IMGDFModule : IUnknown {
  /**
   Called by the host after a module is first created and should be used
   to do perform any initialization required by the module
   \param host the simulation thread host
   \return false if the module experiences a fatal error on initialization
   */
  BOOL STNew(IMGDFSimHost * host);

  /**
   Called once per simulation timestep by the host once the game is running and
   represents the main sim loop
   \param host the simulation thread host
   \param elapsedTime the simulation timestep
   \return false if the module experiences a fatal error updating the scene
  */
  BOOL STUpdate(IMGDFSimHost * host, double elapsedTime);

  /**
   Called by the host to tell the module to cleanup and shutdown as soon as
   possible. This is invoked when external events such as clicking the windows
   close button try to close the application. After being invoked it is the
   modules responsibility to call the ->Shutdown() function as soon as possible
   in order to actually terminate the application. This function may be called
   multiple times.
   \param host the simulation thread host
   */
  void STShutDown(IMGDFSimHost * host);

  /**
   Called by the host immediately before the first call to RTDrawScene
   \param host the render thread host
   \return false if the module experiences a fatal error
  */
  BOOL RTBeforeFirstDraw(IMGDFRenderHost * host);

  /**
   Called by the host once per render frame. The module should do any rendering
   required for the current frame in here
   \param host the render thread host
   \param alpha how far between the current and next simulation frame (0-1)
   \return false if the module experiences a fatal error drawing the scene
  */
  BOOL RTDraw(IMGDFRenderHost * host, double alpha);

  /**
  Called by the host if the swap chain options need to be changed, or the
  display window needs to be resized. The module should clear out all references
  to the previous back buffer so a new resized backbuffer can be set
  \param host the render thread host
  \return false if the module experiences a fatal error
  */
  BOOL RTBeforeBackBufferChange(IMGDFRenderHost * host);

  /**
  Called by the host after the swap chain options has been changed, or the
  display window has been resized. The module should re-acquire references to
  the new backbuffer or resize any backbuffer size dependent resources u
  \param host the render thread host
  \return false if the module experiences a fatal error
  */
  BOOL RTBackBufferChange(IMGDFRenderHost * host);

  /**
  Called by the host if the dxgi device needs to be removed. The module should
  clean out all device dependent resources and references to the old d3d device,
  which will now be invalid.
  \param host the render thread host
  \return false if the module experiences a fatal error
  */
  BOOL RTBeforeDeviceReset(IMGDFRenderHost * host);

  /**
  Called by the host after the dxgi device has been reset, the module should
  recreate any device dependent resources that were removed in
  RTBeforeDeviceReset
  \param host the render thread host
  \return false if the module experiences a fatal error
  */
  BOOL RTDeviceReset(IMGDFRenderHost * host);

  /**
  Called by the host when a fatalError event occurs.
  This method gives the module a chance to clean up any memory/open files etc.
  as best it can before the host aborts. Methods on the render and sim hosts
  should not be accessed from within this method
  */
  void Panic();
};
